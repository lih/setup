#!/bin/bash
: ${HS_PREFIX=/${SETUP_PREFIX}}

: ${HS_BUILD=${HS_PREFIX}.build}
: ${HS_ETC=${HS_PREFIX}etc}
: ${HS_BIN=${HS_PREFIX}.dist/bin}
: ${HS_SRC=${HS_PREFIX}src}
: ${HS_PKG=$HS_BUILD/package}
: ${HS_DEP=$HS_BUILD/deps}
: ${HS_CONF=$HS_BUILD/conf}
: ${HS_POOL=$HS_BUILD/pool}
: ${HS_OBJ=$HS_BUILD/obj}
: ${HS_LOG=$HS_BUILD/log}

GHC_VERSION="$(ghc --version)"
GHC_VERSION="${GHC_VERSION#* version }"
GHC_VNUM="${GHC_VERSION:0:1}${GHC_VERSION:2:2}"

function Hackage.get() {
    local pkg="${2#-}"
    mkpdir "$1"
    curl -Ls http://hackage.haskell.org/package/"$pkg"/"$pkg".tar.gz > "$1"
}

function Tar.find() {
    mkpdir "$1"
    tar -tzf "$3" | grep -e "${2#-}" > "$1"
}
function Tar.get() {
    mkpdir "$1"
    tar -xzOf "$2" "$(< "$3")" > "$1"
}

function Cabal.section() {
    local field="${2#-}"
    mkpdir "$1"
    local text="$(sed -rn '
/^library/I,/^\S/{
  /^\s+'"$field"':/I{
    :loop;{
      /^\s*--/{n;bloop}
      /'"$field"':/bnext-line
      /^\S|:|\bif\b/bendloop
      :next-line
      s/'"$field"'://i;p;n
      bloop
    }
    :endloop	
  }
}
' "$3")" || return
    if [ -n "$4" ]; then
	local IFS="$IFS${4#-}"
    fi
    printf "%s\n" $text > "$1"
}

function HS.GHCAutoConf() {
    cat > "$1.c" <<EOF
#include <stdio.h>
#include <stdint.h>

int main() {
    printf("#define SIZEOF_WORD32      %d\n",sizeof(uint32_t));
    printf("#define ALIGNMENT_WORD32   %d\n",sizeof(uint32_t));

    printf("#define SIZEOF_INT8_T     %d\n",sizeof(int8_t));
    printf("#define ALIGNMENT_INT8_T  %d\n",sizeof(int8_t));
    printf("#define SIZEOF_INT16_T    %d\n",sizeof(int16_t));
    printf("#define ALIGNMENT_INT16_T %d\n",sizeof(int16_t));
    printf("#define SIZEOF_INT32_T    %d\n",sizeof(int32_t));
    printf("#define ALIGNMENT_INT32_T %d\n",sizeof(int32_t));
    printf("#define SIZEOF_INT64_T    %d\n",sizeof(int64_t));
    printf("#define ALIGNMENT_INT64_T %d\n",sizeof(int64_t));

    printf("#define SIZEOF_UINT8_T     %d\n",sizeof(uint8_t));
    printf("#define ALIGNMENT_UINT8_T  %d\n",sizeof(uint8_t));
    printf("#define SIZEOF_UINT16_T    %d\n",sizeof(uint16_t));
    printf("#define ALIGNMENT_UINT16_T %d\n",sizeof(uint16_t));
    printf("#define SIZEOF_UINT32_T    %d\n",sizeof(uint32_t));
    printf("#define ALIGNMENT_UINT32_T %d\n",sizeof(uint32_t));
    printf("#define SIZEOF_UINT64_T    %d\n",sizeof(uint64_t));
    printf("#define ALIGNMENT_UINT64_T %d\n",sizeof(uint64_t));

    printf("#define SIZEOF_VOID_P      %d\n",sizeof(void*));
    printf("#define ALIGNMENT_VOID_P   %d\n",sizeof(void*));

    printf("#define SIZEOF_FLOAT       %d\n",sizeof(float));
    printf("#define ALIGNMENT_FLOAT    %d\n",sizeof(float));
    printf("#define SIZEOF_DOUBLE      %d\n",sizeof(double));
    printf("#define ALIGNMENT_DOUBLE   %d\n",sizeof(double));

    return 0;
}
EOF
    gcc "$1.c" -o "$1.x"
    rm -f "$1.c"
    "$1.x" > "$1"
    rm -f "$1.x"
}
function HS.isLocalMod() {
    local modpath=( "$SETUP_ROOT$HS_SRC/"*/*"/source/$1.hs" )
    [ -e "$modpath" ] && {
	modpath="${modpath#$SETUP_ROOT$HS_SRC/}"
	HS_MOD_PATH="${modpath%/source/*}"
    }
}
function HS.pp() {
    mkpdir "$1"
    cpp -traditional-cpp -undef -DWORLD_IMPORTS -I"$SETUP_ROOT$HS_POOL" -w -include "$3" "$2" > "$1"
}
function HS.cc() {
    mkpdir "$1"
    ghc -c -I"$SETUP_ROOT$HS_POOL" "$2" -o "$1"
}
function HS.depends() {
    mkpdir "$1"
    sed -rn 's/^import(\s+qualified)?\s+([A-Za-z0-9_.]+).*$/\2/p' "$2" | grep -vxf "$3" > "$1" || :
}
function HS.get() {
    local name="$(< "$3")"
    mkpdir "$1"
    case "$name" in
	*.hsc) hsc2hs -o "$1" <(tar -xzOf "$2" "$name");;
	*.hs)  tar -xzOf "$2" "$name" > "$1";;
    esac
}
function HS.pkgMods() {
    local pkg
    mkpdir "$1"
    for pkg in $(< "$2"); do
	printf "%s\n" $(ghc-pkg field "$pkg" exposed-modules)
    done | sort -u > "$1"
}
function HS.compile() {
    mkpdir "$1" "$2"
    ghc -optP --include="$4" -o "$1" -ohi "$2" -I"$SETUP_ROOT$HS_POOL" -i"$SETUP_ROOT$HS_OBJ" -c ${5:+$(< "$5")} "$3"
}
function HS.ld() {
    mkpdir "$1"
    ghc -o "$1" "${@:2}"
}
function HS.fullPkgs() {
    local pkg vers
    mkpdir "$1"
    for pkg in $(< "$2"); do
	vers="$(ghc-pkg field "$pkg" version)"
	vers="${vers#version: }"
	printf "%s\n" "$pkg-$vers"
    done > "$1"
}
function HS.macros.genPkg() {
    local pName vers a b c; local -a vns
    pName="${1%-*}"
    pName="${pName//-/_}"
    vers="${1##*-}"
    vns=( ${vers//./ } 0 0 )
    a="${vns[0]}" ; b="${vns[1]}" ; c="${vns[2]}"
    cat <<EOF
#define VERSION_$pName "$vers"
#undef MIN_VERSION_$pName
#define MIN_VERSION_$pName(maj1,maj2,min) ( maj1 < $a || (maj1) == $a && (maj2) < $b || (maj1) == $a && (maj2) == $b && (min) <= $c )
EOF
}
function HS.macros() {
    local -a packages=( $(< "$2") ) core_packages=( $(< "$3") )
    mkpdir "$1"
    {
	cat <<EOF
#ifndef __GLASGOW_HASKELL__
#define __GLASGOW_HASKELL__ $GHC_VNUM
#endif
#define HASH_TOK #
#define CALLCONV ccall
#define USE_DLSYM 1
#define IS_WINDOWS False
#define DATA_DIR "$INSTALL/share/world"
#define EXE_EXTENSION ""
#define _FILE_OFFSET_BITS 64
EOF
	for p in "${packages[@]}"; do HS.macros.genPkg "$p"; done
	echo "#if __GLASGOW_HASKELL__ < 800 || defined(WORLD_IMPORTS)"
	for p in "${core_packages[@]}"; do HS.macros.genPkg "$p"; done
	echo "#endif"
    } > "$1"
}
function HS.includes() {
    mkpdir "$1"
    sed -rn 's,^\s*#\s*include\s*"(.*)"\s*$,\1,p' "$2" > "$1"
}

function HS.auto_files() {
    [[ "$1" =~ ^("$HS_PKG"|"$HS_DEP"|"$HS_CONF"|"$HS_POOL"|"$HS_OBJ"|"$HS_BIN")/(.*) ]] && {
	local root="${BASH_REMATCH[1]}" path="${BASH_REMATCH[2]}"
	case "$root" in
	    "$HS_CONF")
		case "$path" in
		    manifest.files)	prepare "$1" = Foreach -'$HS_PKG/$word/conf.manifest' "$HS_ETC/packages";;
		    manifest)		prepare "$1" = Sorted @"$HS_CONF/manifest.files";;
		    c-manifest.files)	prepare "$1" = Foreach -'$HS_PKG/$word/conf.c-manifest' "$HS_ETC/packages";;
		    c-manifest)         prepare "$1" = Sorted @"$HS_CONF/c-manifest.files";;
		    base-packages.full) prepare "$1" = HS.fullPkgs "$HS_ETC/base-packages";;
		    base-modules)       prepare "$1" = HS.pkgMods "$HS_ETC/base-packages";;
		    macros.h)           prepare "$1" = HS.macros "$HS_ETC/packages" "$HS_CONF/base-packages.full";;
		esac;;
	    "$HS_PKG")
		[[ "$path" =~ ^([^/]*)/(package\.(tar\.gz|cabal(\.ar-path)?)|modules|conf.(c-)?manifest|(all-|other-|)extensions|(ext-|ghc-|)options|c-sources|includes)$ ]] && {
		    local pkg="${BASH_REMATCH[1]}" file="${BASH_REMATCH[2]}"
		    case "$file" in
			package.tar.gz)		prepare "$1" = Hackage.get -"$pkg";;
			package.cabal.ar-path)  prepare "$1" = Tar.find -"${pkg%-*}"'\.cabal$' "$HS_PKG/$pkg/package.tar.gz";;
			package.cabal)		prepare "$1" = Tar.get "$HS_PKG/$pkg/package.tar.gz" "$HS_PKG/$pkg/package.cabal.ar-path";;
			modules)                prepare "$1" = Cabal.section -'(exposed|other)'-modules "$HS_PKG/$pkg/package.cabal" -',';;
			extensions)             prepare "$1" = Cabal.section -extensions "$HS_PKG/$pkg/package.cabal" -,;;
			other-extensions)       prepare "$1" = Cabal.section -other-extensions "$HS_PKG/$pkg/package.cabal" -,;;
			c-sources)              prepare "$1" = Cabal.section -c-sources "$HS_PKG/$pkg/package.cabal" -,;;
			includes)               prepare "$1" = Cabal.section -'(includes|install-includes)' "$HS_PKG/$pkg/package.cabal" -,;;
			all-extensions)         prepare "$1" = Concat "$HS_PKG/$pkg/"{other-,}extensions;;
			ghc-options)            prepare "$1" = Cabal.section -ghc-options "$HS_PKG/$pkg/package.cabal";;
			ext-options)            prepare "$1" = Foreach -'-X$word' "$HS_PKG/$pkg/all-extensions";;
			options)                prepare "$1" = Concat "$HS_PKG/$pkg/"{ext,ghc}-options;;
			conf.manifest)          prepare "$1" = Foreach -'$word:'"$pkg" "$HS_PKG/$pkg/modules";;
			conf.c-manifest)        prepare "$1" = Foreach -'$word:'"$pkg" "$HS_PKG/$pkg/c-sources" "$HS_PKG/$pkg/includes";;
		    esac
		};;
	    "$HS_DEP"|"$HS_POOL"|"$HS_OBJ")
		[[ "$path" =~ ^(.*)\.((c-)?pkg-name|(c-)?pkg\.file|hs(\.ar-path|pp(\.files)?|)|depends|(c-)?o(\.(c-)?files)?|full-o\.files|hi|options\.file|full-deps(\.files)?|pkg-deps(\.files|\.local)?|[ch](-sources(\.files)?|\.ar-path|)|incs|full-incs(\.files)?|bin-(hs|c)-o\.files)$ ]] && {
		    local mod="${BASH_REMATCH[1]}" ext="${BASH_REMATCH[2]}"
		    case "$root:$ext"	in
			"$HS_DEP":pkg-name)
			    if HS.isLocalMod "$mod"; then
				prepare "$1" = Echo -"${HS_MOD_PATH//\//-}"
			    else
				prepare "$1" = Lookup -"${mod//\//.}" "$HS_CONF/manifest"
			    fi;;
			"$HS_DEP":c-pkg-name)   prepare "$1" = Lookup -"$mod" "$HS_CONF/c-manifest";;
			"$HS_DEP":pkg.file)	prepare "$1" = Foreach -'$HS_PKG/$word/package.tar.gz' "$HS_DEP/$mod.pkg-name";;
			"$HS_DEP":c-pkg.file)	prepare "$1" = Foreach -'$HS_PKG/$word/package.tar.gz' "$HS_DEP/$mod.c-pkg-name";;
			"$HS_DEP":c.ar-path)    prepare "$1" = Tar.find -"$mod\\.c\$" @"$HS_DEP/$mod.c-pkg.file";;
			"$HS_DEP":h.ar-path)    prepare "$1" = Tar.find -"$mod\\.h\$" @"$HS_DEP/$mod.c-pkg.file";;
			"$HS_POOL":c)           prepare "$1" = Tar.get @"$HS_DEP/$mod.c-pkg.file" "$HS_DEP/$mod.c.ar-path";;
			"$HS_POOL":h)
			    if [ -e "$SETUP_ROOT$HS_ETC/base-files/$mod.h" ]; then
				prepare "$1" = Copy "$HS_ETC/base-files/$mod.h"
			    elif [ "$mod" == ghcautoconf ]; then
				prepare "$1" = HS.GHCAutoConf
			    else
				prepare "$1" = Tar.get @"$HS_DEP/$mod.c-pkg.file" "$HS_DEP/$mod.h.ar-path"
			    fi;;
			"$HS_DEP":hs.ar-path)	prepare "$1" = Tar.find -"$mod\\.hsc\\?\$" @"$HS_DEP/$mod.pkg.file";;
			"$HS_POOL":hs)
			    if HS.isLocalMod "$mod"; then
				prepare "$1" = Copy "$HS_SRC/$HS_MOD_PATH/source/$mod.hs"
 			    else
				prepare "$1" = HS.get @"$HS_DEP/$mod.pkg.file" "$HS_DEP/$mod.hs.ar-path"
			    fi;;
			"$HS_DEP":hspp.files)           prepare "$1" = Foreach -'$HS_POOL/$word' "$HS_DEP/$mod.hs.full-incs";;
			"$HS_POOL":hspp)		prepare "$1" = HS.pp "$HS_POOL/$mod.hs" "$HS_CONF/macros.h" @"$HS_DEP/$mod.hspp.files";;
			"$HS_DEP":depends)		prepare "$1" = HS.depends "$HS_POOL/$mod.hspp" "$HS_CONF/base-modules";;
			"$HS_DEP":pkg-deps.files)	prepare "$1" = Foreach -'$HS_DEP/${word//.//}.pkg-deps' "$HS_DEP/$mod.depends";;
			"$HS_DEP":pkg-deps)		prepare "$1" = Sorted "$HS_DEP/$mod.pkg-name" @"$HS_DEP/$mod.pkg-deps.files";;
			"$HS_DEP":pkg-deps.local)	prepare "$1" = Filter "$HS_DEP/$mod.pkg-deps" "$HS_ETC/local-packages" -v;;
			"$HS_DEP":full-deps.files)	prepare "$1" = Foreach -'$HS_DEP/${word//.//}.full-deps' "$HS_DEP/$mod.depends";;
			"$HS_DEP":full-deps)		prepare "$1" = Sorted "$HS_DEP/$mod.depends" @"$HS_DEP/$mod.full-deps.files";;
			"$HS_DEP":incs)			prepare "$1" = HS.includes "$HS_POOL/$mod";;
			"$HS_DEP":full-incs.files)	prepare "$1" = Foreach -'$HS_DEP/$word.full-incs' "$HS_DEP/$mod.incs";;
			"$HS_DEP":full-incs)		prepare "$1" = Sorted "$HS_DEP/$mod.incs" @"$HS_DEP/$mod.full-incs.files";;
			"$HS_DEP":c-sources.files)	prepare "$1" = Foreach -'$HS_PKG/$word/c-sources' "$HS_DEP/$mod.pkg-deps.local";;
			"$HS_DEP":c-sources)		prepare "$1" = Sorted @"$HS_DEP/$mod.c-sources.files";;
			"$HS_DEP":o.c-files)		prepare "$1" = Foreach -'$HS_OBJ/${word#$HS_POOL/}-o' "$HS_DEP/$mod.c-sources";;
			"$HS_DEP":o.files)		prepare "$1" = Foreach -'$HS_OBJ/${word//.//}.o' "$HS_DEP/$mod.depends";;

			"$HS_DEP":options.file)
			    if HS.isLocalMod "$mod"; then
				prepare "$1" = Echo -"$HS_SRC/$HS_MOD_PATH/options"
			    else
				prepare "$1" = Foreach -'$HS_PKG/$word/options' "$HS_DEP/$mod.pkg-name"
			    fi;;
			"$HS_DEP":c-o.files)       prepare "$1" = Foreach -'$HS_POOL/$word' "$HS_DEP/$mod.c.full-incs";;
			"$HS_OBJ":c-o)             prepare "$1" = HS.cc "$HS_POOL/$mod.c" @"$HS_DEP/$mod.c-o.files";;
			"$HS_OBJ":o)               prepare "$1" "${1/.o/.hi}" = HS.compile "$HS_POOL/$mod.hs" "$HS_CONF/macros.h" @"$HS_DEP/$mod.options.file" @"$HS_DEP/$mod.o.files" @"$HS_DEP/$mod.o.c-files";;

			"$HS_DEP":bin-hs-o.files)  prepare "$1" = Foreach -'$HS_OBJ/${word//.//}.o' "$HS_DEP/$mod.full-deps";;
			"$HS_DEP":bin-c-o.files)   prepare "$1" = Foreach -'$(word="${word#$HS_POOL/}"; echo "$HS_OBJ/$word-o")' "$HS_DEP/$mod.c-sources";;
			*) return 1;;
		    esac
		};;
	    "$HS_BIN") prepare "$1" = HS.ld "$HS_OBJ/${path//.//}.o" @"$HS_DEP/${path//.//}.bin-"{c,hs}"-o.files";;
	esac
    }    
}
Setup.addHooks HS.auto_files

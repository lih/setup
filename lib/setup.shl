#!/bin/bash
declare -g \
	SETUP_JOBS=8 \
        SETUP_STATE_FILE= \
        SETUP_ROOT="$PWD" \
	SETUP_NOW="$(date +"%s 10#%N")" \
	SETUP_PREFIX= \
	SETUP_TMPDIR="$(mktemp -d)"
declare -ga \
	SETUP_FAILED=( ) \
        SETUP_SOURCE_FILES=( ) \
        SETUP_AUTO_DEPEND_HOOKS=( )
declare -gA \
	SETUP_STATE=( ) \
	SETUP_LEAVES=( ) \
        SETUP_MODULES=( ) \
        SETUP_ARGS=( )

shopt -s extglob

declare arg
for arg; do
    SETUP_ARGS[${arg%%=*}]="${arg##*([^=])?(=)}"
done

if [ "${SETUP_LOGLEVEL:-0}" -gt 0 ]; then
    function Setup.log.INFO() { printf "[INFO:${BASHPID:-$$}]: %s\n" "$*" >&2; }
else
    function Setup.log.INFO() { :; }
fi
function Setup.log.CRIT() { printf "[CRIT:${BASHPID:-$$}]: %s\n" "$*" >&2; }

function Setup.log() { Setup.log."$1" "${@:2}"; }
function Setup.trace() { Setup.log INFO "$@" >&2; "$@"; }

function Setup.send() {
    (
        read -u"$3" -n1
        printf . >&"$1"
        if [ -n "$5" ]; then printf "${@:5}"; fi
        printf "%s\n" "$4" >&"$2"
    ) &
}
function Setup.receive() {
    read -u"$1" -n1 \
        && read -r -u"$2" "$4"
    local ret="$?"
    printf . >&"$3" &
    return "$ret"
}
function Setup.mkqueue() {
    local sem stream mutex
    mkfifo "$SETUP_TMPDIR/$2"_{sem,stream,mutex}
    exec {sem}<>"$SETUP_TMPDIR/${2}_sem" \
	 {stream}<>"$SETUP_TMPDIR/${2}_stream" \
	 {mutex}<>"$SETUP_TMPDIR/${2}_mutex"
    printf . >&"$mutex" &
    declare -g "$1"="$sem $stream $mutex"
}
Setup.mkqueue SETUP_WORKER worker
Setup.mkqueue SETUP_MASTER master

function Setup.dumpState() {
    {
	for k in "${!SETUP_STATE[@]}"; do if [[ "$k" == *.needed ]]; then unset SETUP_STATE[$k]; fi; done
	declare -p SETUP_STATE SETUP_SOURCE_FILES
    } | sed 's/^declare/declare -g/'
}
function Setup.addArr() {
    local arr="$1" i="${SETUP_STATE[$1.n]:-0}" arg
    shift
    for arg; do
        SETUP_STATE[$arr.$i]="$arg"
        ((i++))
    done
    SETUP_STATE[$arr.n]=$i
}
function Setup.setArr() {
    local arr="$1" i=0 arg
    shift
    for arg; do
        SETUP_STATE[$arr.$i]="$arg"
        ((i++))
    done
    SETUP_STATE[$arr.n]=$i
}
function Setup.getArr() {
    local __var="$1" __arr="$2" n i
    n="${SETUP_STATE[$__arr.n]:-0}"
    shift 2
    
    eval "$__var=( )"
    for ((i=0;i<n;i++)); do
        eval "$__var+=( \"\${SETUP_STATE[\$__arr.$i]}\" )"
    done    
}
function Setup.setVal() { SETUP_STATE[$1]="$2"; }

function Setup.addPrefix() {
    local __arr="$1"
    if [ -n "$SETUP_PREFIX" ]; then
	eval '
'$__arr'=( "${'$__arr'[@]/#//}" )
'$__arr'=( "${'$__arr'[@]/#\/-/-}" )
'$__arr'=( "${'$__arr'[@]/#\/@\//@}" )
'$__arr'=( "${'$__arr'[@]/#\/\//}" )
'$__arr'=( "${'$__arr'[@]/#\/@/@$SETUP_PREFIX}" )
'$__arr'=( "${'$__arr'[@]/#\//$SETUP_PREFIX}" )
'
    else
	eval '
'$__arr'=( "${'$__arr'[@]/#\//}" )
'$__arr'=( "${'$__arr'[@]/#@\//@}" )
'
    fi
}

function Setup.runDependHooks() {
    [ "${SETUP_STATE[$1.can]:+x}" == x ] || {
	for hook in "${SETUP_AUTO_DEPEND_HOOKS[@]}"; do
	    "$hook" "/$1" && return
        done
        false
    } || {
        [ -e "$SETUP_ROOT/$1" ] && {
	    SETUP_STATE[$1.can]="$1"
	    SETUP_STATE[$1.status]=2:done
	    SETUP_STATE[$1.timestamp]="$(date +"%s 10#%N" -r "$SETUP_ROOT/$1")"
	    SETUP_SOURCE_FILES+=( "$1" )
	}
    } || {
        Setup.log CRIT "Missing dependency: $1"
        return 1
    }
}
function Setup.primeCan.unlink() {
    local can="$1" i="$2" arg newval ind newind sz

    arg="${SETUP_STATE[$can.full-args.$i]}"
    ind="${arg%%:*}"
    arg="${arg#*:}"
    sz="${SETUP_STATE[$arg.next-primed.n]}"
    newval="${SETUP_STATE[$arg.next-primed.$((sz-1))]}"
    newind="${newval%%:*}"
    newval="${newval#*:}"
    
    SETUP_STATE[$arg.next-primed.$ind]="$newind:$newval"
    SETUP_STATE[$arg.next-primed.n]=$((sz-1))
    SETUP_STATE[$newval.full-args.$newind]="$ind:$arg"
}
function Setup.primeCan.link() {
    local can="$1" i="$2" arg="$3" sz
    sz="${SETUP_STATE[$arg.next-primed.n]:-0}"
    SETUP_STATE[$arg.next-primed.$sz]="$i:$can"
    SETUP_STATE[$arg.next-primed.n]=$((sz+1))
    SETUP_STATE[$can.full-args.$i]="$sz:$arg"
}
function Setup.primeCan() {
    local argc=0 arg argtr can="$1"
    local -a args=( ) newargs fullargs=( ) hiddenargs=( )
    Setup.getArr args "$can.args"
    for arg in "${args[@]}"; do
        case "$arg" in
	    @*)      argtr= ;;&
	    @*\{*\}) argtr="${arg#*\{}"; argtr="${argtr%\}}" ;&
            @*)
		arg="${arg%\{*\}}"
		hiddenargs+=( "${arg#@}" )
		newargs=( $(< "${arg#@}") )
		case "$argtr" in
		    '') :;;
		    \"*\")
			local -a tmp=( "${newargs[@]}" )
			local word
			newargs=( )
			for word in "${tmp[@]}"; do
			    eval "newargs+=( $argtr )"
			done
			;;
		esac
		Setup.addPrefix newargs
		fullargs+=( "${newargs[@]}" );;
            *)  fullargs+=( "$arg" );;
        esac
    done
    local -a old_args
    Setup.getArr old_args "$can.full-args"
    old_args=( "${old_args[@]#*:}" )
    local sz="${#fullargs[@]}" oldsz="${#old_args[@]}" i
    for ((i=0;i<sz;i++)); do
	arg="${fullargs[i]}"
        case "$arg" in
            -*)
		if [[ "${old_args[i]}" != @(''|-*) ]]; then
		    Setup.primeCan.unlink "$can" "$i"
		fi
		SETUP_STATE[$can.full-args.$i]="0:$arg"
		;;
            *)
                Setup.runDependHooks "$arg" || {
                    local ret="$?"
                    Setup.log CRIT "  - needed for $can"
                    return "$ret"
                }
                arg="${SETUP_STATE[$arg.can]}"
		case "${old_args[i]}" in
		    "$arg") :;;
		    *)
			if [[ "${old_args[i]}" != @(''|-*) ]]; then
			    Setup.primeCan.unlink "$can" "$i"
			fi
			Setup.primeCan.link "$can" "$i" "$arg";;
		esac
                if [ "${SETUP_STATE[$arg.status]}" != 2:done ]; then
                    ((argc++))
                fi
                ;;
        esac
    done
    Setup.setVal "$can.full-args.n" "$sz"
    while (( i < oldsz )); do
	Setup.primeCan.unlink "$can" "$i"
	((i++))
    done
    
    Setup.setVal "$can.argc" "$argc"
    Setup.setVal "$can.status" 1:primed
    Setup.setArr "$can.hidden-args" "${hiddenargs[@]}"
    if ((argc == 0)); then
        SETUP_LEAVES[$can]=1
    fi
}

function Setup.isUpToDate() {
    local dst="$1" arg; shift
    for arg; do
        if [[ "$arg" != -* && "$SETUP_ROOT/$dst" -ot "$SETUP_ROOT/$arg" ]]; then return 1; fi
    done
    [ -e "$SETUP_ROOT/$dst" ]
}
function Setup.runLeaves() {
    local leaf prog
    local -a args hargs dst
    for leaf in "${!SETUP_LEAVES[@]}"; do
        if [ "${SETUP_STATE[$leaf.cmd]:+x}" == '' ] \
	       || {
               Setup.getArr args "$leaf.full-args"
	       args=( "${args[@]#*:}" )
	       Setup.getArr hargs "$leaf.hidden-args"
               Setup.getArr dst "$leaf.targets"
	       
	       Setup.isUpToDate "$dst" "${args[@]}" "${hargs[@]}"  
	   }; then
            SETUP_UPTODATE+=( "$leaf" )
        else
            local -a cmd=( "${SETUP_STATE[$leaf.cmd]}" "${dst[@]}" "${args[@]}" )
            cmd=( "${cmd[@]//\'/\'\\\'\'}" )
            cmd=( "${cmd[@]/%/\'}" )
            cmd=( "${cmd[@]/#/\'}" )
            Setup.send $SETUP_WORKER "$leaf ${cmd[*]}" '%-20s %s\n' "${SETUP_STATE[$leaf.cmd]}" "${dst[*]}"
        fi
    done
    SETUP_LEAVES=( )
}
function Setup.ts.olderThan() {
    (( $1 < $3 || ($1 == $3 && $2 < $4) ))
}
function Setup.need() {
    if [ "${SETUP_STATE[$1.needed]}" != true ]; then
	SETUP_STATE[$1.needed]=true
	
	local -a nexts 
	local next arr edgeType=2:done nextEdgeType
	for arr in args full-args hidden-args; do
	    Setup.getArr nexts "$1.$arr"
	    if [ "$arr" == full-args ]; then nexts=( "${nexts[@]#*:}" ); fi
	    for next in "${nexts[@]}"; do
		if [[ "$next" != -* ]]; then
		    next="${next%\{*\}}"
		    next="${next#@}"
		    Setup.need "$next"
		    if [[ "${SETUP_STATE[$next.status]}" == 2:done
			   && "${SETUP_STATE[$1.status]}" == 2:done ]] \
			       && Setup.ts.olderThan ${SETUP_STATE[$1.timestamp]:-0 0} ${SETUP_STATE[$next.timestamp]:-0 0}; then

			# echo "$1 older than $next" >&2
			if [[ "$arr" == hidden-args || ( "$arr" == args && "$next" == @* ) ]]; then
			    nextEdgeType=0:defined
			else
			    nextEdgeType=1:primed
			fi
			if [[ "$edgeType" > "$nextEdgeType" ]]; then edgeType="$nextEdgeType"; fi
		    fi
		fi
	    done
	done
	if [[ "${SETUP_STATE[$1.status]}" == 2:done && "$edgeType" != 2:done ]]; then
	    SETUP_STATE[$1.status]="$edgeType"
	    if [ "$edgeType" == 0:defined ]; then
		Setup.primeCan "$1"
	    fi
	    Setup.invalidate "$1"
	fi
	if [[ "${SETUP_STATE[$1.status]}" == 1:primed && "${SETUP_STATE[$1.argc]}" -eq 0 ]]; then
	    SETUP_LEAVES[$1]=1
	fi
    fi	
}

function Setup.hook() { SETUP_AUTO_DEPEND_HOOKS=( "$@" "${SETUP_AUTO_DEPEND_HOOKS[@]}" ); }
function Setup.targets() {
    local tgt
    for tgt; do
	[ "${SETUP_ARGS[${tgt#-}]+x}" == x ] && {
	    if [[ "$tgt" != -* ]]; then printf "%s\n" "${SETUP_ARGS[${tgt#-}]}"; fi
	    return 0
	}
    done
    return 1
}
function Setup.invalidate() {
    local file="$1" next
    local stat="${SETUP_STATE[$file.status]}"
    local -a nexts

    Setup.getArr nexts "$file.next-defined"
    for next in "${nexts[@]}"; do
	case "${SETUP_STATE[$next.status]}" in
	    0:defined) (( SETUP_STATE[$next.depc]+=1 ));;
	    *) SETUP_STATE[$next.status]=0:defined
	       SETUP_STATE[$next.depc]=1 ;;&
	    2:done) Setup.invalidate "$next" ;;
	esac
    done

    Setup.getArr nexts "$file.next-primed"
    for next in "${nexts[@]#*:}"; do
	case "${SETUP_STATE[$next.status]}" in
	    1:primed) (( SETUP_STATE[$next.argc]+=1 ));;
	    2:done) SETUP_STATE[$next.status]=1:primed
		    SETUP_STATE[$next.argc]=1
		    Setup.invalidate "$next";;
	esac
    done
}
function Setup.state-file() {
    if [ -z "$SETUP_STATE_FILE" ]; then
	SETUP_STATE_FILE="$1"
	if [ -r "$SETUP_STATE_FILE" ]; then
	    source "$SETUP_STATE_FILE"
	    local src ts
	    for src in "${SETUP_SOURCE_FILES[@]}"; do
		ts="$(date +"%s 10#%N" -r "$src")"
		if [ "${SETUP_STATE[$src.timestamp]}" != "$ts" ]; then
		    SETUP_STATE[$src.timestamp]="$ts"
		fi
	    done
	fi
    fi
}
function Setup.use() {
    local mod
    for mod; do
	if [ "${SETUP_MODULES[$mod]:+x}" == '' ]; then
	    source "$SETUP_INSTALL_DIR/lib/setup.d/${mod%.shl}.shl"
	    SETUP_MODULES[$mod]=true
	fi
	if [ -r "${SETUP_USER_MODULES:-.setup/lib}/$mod.shl" ]; then
	    source "${SETUP_USER_MODULES:-.setup/lib}/$mod.shl"
	fi
    done
}
function Setup.load() {
    local path="${1%/*}" file="${1##*/}"
    shift
    local SETUP_PREFIX="$SETUP_PREFIX$path/"
    pushd "$path" >/dev/null && {
	source "$file"
	popd >/dev/null
    }
}

function Setup.atexit() {
    if [ -n "$SETUP_STATE_FILE" ]; then
	Setup.dumpState >"$SETUP_STATE_FILE"
    fi
    rm -rf "$SETUP_TMPDIR"
}
trap Setup.atexit EXIT

# Usage : prepare file... = cmd [file|@file|-tag]...
function prepare() {
    local -a targets
    while [ "$1" != '=' ]; do
        targets+=( "$1" )
        shift
    done
    shift
    Setup.addPrefix targets
    local can="$targets" 
    if [ "${SETUP_STATE[$can.can]:+x}" == '' ]; then
	local arg tgt depc=0 nflags=0
	Setup.setArr "$can.targets" "${targets[@]}"
	for tgt in "${targets[@]}"; do
            Setup.setVal "$tgt.can" "$can"
	done
	Setup.setVal "$can.cmd" "$1"
	shift
	local -a args=( "$@" )
	Setup.addPrefix args
	Setup.setArr "$can.args" "${args[@]}"
	for arg in "${args[@]}"; do
	    case "$arg" in
		-*) ((nflags++));;
		@*)
		    arg="${arg%\{*\}}"
		    arg="${arg#@}"
		    Setup.runDependHooks "$arg" || {
			local ret="$?"
			Setup.log CRIT "  - needed for $can"
			return "$ret"
		    }
		    arg="${SETUP_STATE[$arg.can]}"
		    Setup.addArr "$arg.next-defined" "$can"
		    if [ "${SETUP_STATE[$arg.status]}" != 2:done ]; then
			((depc++))
		    fi
		    ;;
	    esac
	done
	if (( nflags == ${#args[@]} )); then
	    SETUP_SOURCE_FILES+=( "$can" )
	fi
	if ((depc > 0)); then
            Setup.setVal "$can.depc" "$depc"
            Setup.setVal "$can.status" 0:defined
	else
            Setup.primeCan "$can"
	fi
    fi
    Setup.need "$can"
}
# Usage: setup file...
function setup() {
    local -a workers=( ) SETUP_UPTODATE=( )
    for ((i=0;i<SETUP_JOBS;i++)); do
        (
            while Setup.receive $SETUP_WORKER msg; do
                Setup.log INFO "[WORKER $i] Received $msg"
                key="${msg%% *}"
		logfile="$SETUP_TMPDIR/log/$key.log"
		mkdir -p "$(dirname "$logfile")"
                eval "${msg#* }" >"$logfile" 2>&1
                Setup.trace Setup.send $SETUP_MASTER "$key $?"
	    done
        ) & workers+=( "$!" )
    done

    local -a args=( "$@" )
    Setup.addPrefix args
    local arg sz
    for arg in "${args[@]}"; do
	Setup.runDependHooks "$arg" || return
	Setup.need "$arg"
    done

    local nl="${#SETUP_LEAVES[@]}" can stat ret=0
    Setup.runLeaves
    while ((nl>0)) && {
	      sz=${#SETUP_UPTODATE[@]};
	      ((sz>0)) && {
		  msg="${SETUP_UPTODATE[sz-1]} 0"
		  unset SETUP_UPTODATE[sz-1]
	      } || Setup.receive $SETUP_MASTER msg
	  }; do
        Setup.log INFO "[MASTER] received $msg"
        can="${msg%% *}"
        stat="${msg#* }"
        ((nl--))
        case "$stat" in
	    0)
		SETUP_STATE[$can.status]='2:done'
		SETUP_STATE[$can.timestamp]="$SETUP_NOW"
		
                local -a nexts
                local x depc argc
                Setup.getArr nexts "$can.next-defined"
                for x in "${nexts[@]}"; do
		    depc="${SETUP_STATE[$x.depc]}"
		    SETUP_STATE[$x.depc]="$((depc-1))"
		    if ((depc == 1)); then
                        Setup.primeCan "$x"
		    fi
		done

                Setup.getArr nexts "$can.next-primed"
                for x in "${nexts[@]#*:}"; do
		    argc="${SETUP_STATE[$x.argc]}"
		    SETUP_STATE[$x.argc]=$((argc-1))
		    if [[ "${SETUP_STATE[$x.needed]}" == true && "$argc" -eq 1 ]]; then
			SETUP_LEAVES[$x]=1
		    fi
                done

                ((nl+=${#SETUP_LEAVES[@]}))
                Setup.runLeaves
                ;;
	    *)
                local -a tgts
		SETUP_STATE[$can.errno]="$stat"
		SETUP_FAILED+=( "$can" )
                Setup.getArr tgts "$can.targets"
                rm -f "${tgts[@]}"
                ret=1
                ;;
        esac
    done

    {
        kill "${workers[@]}"
        wait "${workers[@]}"
    } >/dev/null 2>&1

    return "$ret"
}
